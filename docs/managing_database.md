# How to manage the database

## Entity Relationship Diagram (ERD)

ERD generated by `pgadmin` (see below) can be find [here](database_ERD.png).

## Postgres Admin web app

If you are not a fan of pure SQL or you need to do something complex with the database, you can use Postgres admin web app. It's already prepared in a container image so its installation is very simple.

For the first usage, run:
```bash
$ podman run -it -p 8888:80                      \
      --net openscanhub_internal-network         \
      -e 'PGADMIN_DEFAULT_EMAIL=user@redhat.com' \
      -e 'PGADMIN_DEFAULT_PASSWORD=SuperSecret'  \
      --name pgadmin                             \
      docker.io/dpage/pgadmin4:latest
```

* `-p 8888:80` forwards your local port `8888` to the port `80` inside the container where `pgadmin` listens.
* `--net openscanhub_internal-network` connects the container to the same network as OpenScanHub and database are connected to. The network is created by `podman-compose` and you can check its name first via `podman network ls`.
* `-e PGADMIN_DEFAULT_*` sets the credentials to use with the web app.

Then, you can log into the web app on [localhost:8888](http://localhost:8888/) and set a connection to the database server `db` using username and password from `docker-compose.yml`. The app stores that info so you'll not need to configure it again.

Next time, you only need to start the existing container via `podman start -a pgadmin`.

## Connecting to Postgres

Use the `localhost` hostname and port `5432` to access the `db` container in the following example.

```
$ psql -h $HOSTNAME -p $PORT -U openscanhub
Password for user openscanhub:
psql (15.2, server 12.12)
Type "help" for help.

openscanhub=>
```

You can easily list tables:

```
openscanhub=> \dt
                     List of relations
 Schema |            Name            | Type  |    Owner
--------+----------------------------+-------+-------------
 public | auth_group                 | table | openscanhub
 public | auth_group_permissions     | table | openscanhub
 public | auth_permission            | table | openscanhub
 public | auth_user                  | table | openscanhub
 public | auth_user_groups           | table | openscanhub
 public | auth_user_user_permissions | table | openscanhub
 public | django_admin_log           | table | openscanhub
 public | django_content_type        | table | openscanhub
 public | django_migrations          | table | openscanhub
 public | django_session             | table | openscanhub
 public | django_site                | table | openscanhub
...
```

List schema:

```
openscanhub=> \d auth_user_user_permissions
                                Table "public.auth_user_user_permissions"
    Column     |  Type   | Collation | Nullable |                        Default
---------------+---------+-----------+----------+--------------------------------------------------------
 id            | integer |           | not null | nextval('auth_user_user_permissions_id_seq'::regclass)
 user_id       | integer |           | not null |
 permission_id | integer |           | not null |
Indexes:
    "auth_user_user_permissions_pkey" PRIMARY KEY, btree (id)
    "auth_user_user_permissions_permission_id_1fbb5f2c" btree (permission_id)
    "auth_user_user_permissions_user_id_a95ead1b" btree (user_id)
    "auth_user_user_permissions_user_id_permission_id_14a6b632_uniq" UNIQUE CONSTRAINT, btree (user_id, permission_id)
Foreign-key constraints:
    "auth_user_user_permi_permission_id_1fbb5f2c_fk_auth_perm" FOREIGN KEY (permission_id) REFERENCES auth_permission(id) DEFERRABLE INITIALLY DEFERRED
    "auth_user_user_permissions_user_id_a95ead1b_fk_auth_user_id" FOREIGN KEY (user_id) REFERENCES auth_user(id) DEFERRABLE INITIALLY DEFERRED
```

## Resolving database issues quickly

Let's say that database is in an inconsistent state, migrations were not applied correctly and we need to alter database directly.

The issue:

```
ProgrammingError: column "auth_user_user_permissions.user_id" doesn't exist
```

Can be easily resolved:

```
ALTER TABLE auth_user_user_permissions RENAME COLUMN longnameuser_id TO user_id;
```


Removing `NOT NULL` constraint without migrations:

```
ALTER TABLE auth_user_user_permissions ALTER COLUMN longnameuser_id DROP NOT NULL;
```

## Adding users with a username longer than 30 characters

```python
$ podman exec -it osh-hub osh/hub/manage.py shell
...
>>> from django.contrib.auth.models import Permission
>>> from kobo.django.auth.models import User
>>> p = Permission.objects.get(pk=46)
>>> u2 = User.objects.create(username="errata/errata-web-02.host.qe.eng.pek2.redhat.com@REDHAT.COM")
>>> u2.user_permissions.add(p)
```

## Adding user a permission to submit scans

The prerequisite is that the username is longer than 30 characters and, thus, you can't set it in the Django administration.

```python
$ podman exec -it osh-hub osh/hub/manage.py shell
...
>>> from django.contrib.auth.models import Permission
>>> from kobo.django.auth.models import User
>>> u = User.objects.get(pk=460)  # id of user we want to edit (can be found in URL in admin interface)
>>> u
<User: errata/errata-web-01.host.qe.eng.pek2.redhat.com>
>>> p = Permission.objects.get(pk=46)  # You can find id in admin's html in forms
>>> p
<Permission: scan | permissions | Can submit ET scan via XML-RPC>
>>> u.user_permissions.add(p)
```

That's all. Now refresh the admin interface and check that it's really there.
